# Лабораторные работы по программированию: структура и реализация

## Темы лабораторных работ

1. Задача коммивояжёра
2. Шифрование данных
3. Нечеткий поиск
4. Архивация файлов
5. Бинаризация изображений
6. Брутфорс (метод перебора)

## Этапы реализации каждой лабораторной работы

1. Базовая реализация с использованием HTTP-протоколов (GET, POST)
2. Интеграция веб-сокетов для real-time взаимодействия
3. Внедрение Redis и Celery для асинхронного выполнения задач

## Общие требования к проектам

- Использование FastAPI в качестве веб-фреймворка
- SQLite как база данных
- SQLAlchemy для ORM (Object-Relational Mapping)
- Реализация авторизации по email и паролю
- Аутентификация с использованием JWT (JSON Web Tokens)

## Структура проекта

project/<br>
├── app/<br>
│   ├── api/           # эндпоинты<br>
│   ├── core/          # config <br>
│   ├── db/            # файл базы данных и сессия подключения <br>
│   ├── models/        # модели для базы данных<br>
│   ├── cruds/         # ORM CRUD операции<br>
│   ├── schemas/       # схемы запросов <br>
│   ├── services/      # доп. сервисы, в нашем случае тут будет лежать логика под лабы <br>
│   └── main.py<br>
├── alembic/<br>
└── .env<br>

## Базовые эндпоинты

### Регистрация нового пользователя
@router.post("/sign-up/")
Проверяет, не зарегистрирован ли уже пользователь с таким email.
Если нет, создает нового пользователя и генерирует для него токен.
Возвращает данные созданного пользователя.

### Вход в систему
@router.post("/login/")
Проверяет существование пользователя с указанным email.
Проверяет правильность введенного пароля.
Если все верно, генерирует новый токен для пользователя.
Возвращает данные пользователя с новым токеном.

### Получение информации о текущем пользователе
@router.get("/users/me/")
Возвращает данные авторизованного пользователя.

Данные о пользователе должны сохраняться в базу данных для чего вам надо написать круды.
Необходимо пользоваться alembic для миграции базы данных.

## Задача коммивояжёра (Этап 1)

Задача коммивояжёра (или TSP от англ. travelling salesman problem) — одна из самых известных задач комбинаторной оптимизации, заключающаяся в поиске самого выгодного маршрута, проходящего через указанные города ровно по одному разу с последующим возвратом в исходный город.

[К ознакомлению](https://keldysh.ru/papers/2024/prep2024_8.pdf)

### Эндпоинты:
@app.post("/shortest-path/", response_model=PathResult)
Принимает проиндексированный граф следующего вида (Граф должен быть описан в виде схемы в Pydantic и называться Graph):

{
  "graph": {
    "nodes": [1, 2, 3, 4],
    "edges": [[1, 2, 1], [2, 3, 2], [3, 4, 1], [1, 4, 5]]
  },
  "start": 1,
  "end": 4
}

В данном примере задача получить наикратчайший путь от 1 до 4.

Ответ должен быть следующим в виде схемы PathResult:

{<br>
  "path": [1, 2, 3, 4],<br>
  "total_distance": 4.0<br>
}

Path это путь, а total_distance это дистанция (len(path)).

Рекомендуется использовать алгоритм Дейкстры или А* для поиска кратчайшего пути в графе.

## Шифрование (Этап 1)

### 1. Хаффманическое сжатие данных

Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы[1]. В настоящее время используется во многих программах сжатия данных.

[К ознакомлению](https://habr.com/ru/articles/144200/)

### 2. XOR-Шифрование

Алгоритм xor-шифрования является одним из самых простых линейных симметричных алгоритмов шифрования. Работа алгоритма заключается в последовательном цикличном кодировании символов входной последовательности с символами шифр-ключа с помощью операции сложения по модулю 2 (⊕), иными словами — исключающего ИЛИ (XOR).

[К ознакомлению](https://cmcmsu.info/1course/xor.coding.algs.htm)

### Эндпоинты:

@app.post("/encode", response_model=EncodeResponse)<br>
Принимает текст, сжимает его методом Хаффмана, шифрует XOR и возвращает зашифрованные данные, ключ, коды Хаффмана и информацию о паддинге.

@app.post("/decode")<br>
Принимает зашифрованные данные, ключ, коды Хаффмана и информацию о паддинге, затем расшифровывает и распаковывает данные.

## Нечеткий поиск (Этап 1)
Алгоритмы нечеткого поиска (также известного как поиск по сходству или fuzzy string search) являются основой систем проверки орфографии и полноценных поисковых систем вроде Google или Yandex. Например, такие алгоритмы используются для функций наподобие «Возможно вы имели в виду …» в тех же поисковых системах.
[К ознакомлению](https://habr.com/ru/articles/114997/)

Выберите и реализуйте 2 алгоритма нечеткого поиска из списка:
- Расстояние Левенштейна
- Расстояние Дамерау-Левенштейна
- Алгоритм Bitap с модификациями от Wu и Manber
- Алгоритм расширения выборки
- Метод N-грамм
- Хеширование по сигнатуре
- BK-деревья

### Эндпоинты:

@app.post("/upload_corpus")<br>
Загружает корпус текста для индексации и поиска.

@app.get("/corpuses")<br>
Возвращает список корпусов c идентификаторами.

@app.post("/search_algorithm")<br>
Позволяет указать слово (для поиска), тип алгоритма (которым можно искать), корпус (который можно использовать) и возвращает время работы алгоритма + результат поиска.

## Бинаризация изображения (Этап 1)
Процесс бинаризации – это перевод цветного (или в градациях серого) изображения в двухцветное черно-белое. Главным параметром такого преобразования является порог t – значение, с которым сравнивается яркость каждого пикселя. По результатам сравнения, пикселю присваивается значение 0 или 1.
[К ознакомлению](https://habr.com/ru/articles/278435/)

Выберите алгоритм пороговой обработки из предложенного списка.
Алгоритм сбалансированного порогового отсечения гистограммы:
  1) Алгоритм глобальной бинаризации с критерием Отсу.
  2) Алгоритм адаптивной бинаризации Бернсена.
  3) Алгоритм адаптивной бинаризации Брэдли и Рота.
  4) Алгоритм адаптивной бинаризации Эйквил.
  5) Алгоритм адаптивной бинаризации Ниблэка
  6) Алгоритм адаптивной бинаризации Саувола.
  7) Алгоритм адаптивной бинаризации WAN.
  8) Алгоритм адаптивной бинаризации Сингха.
  9) Алгоритм адаптивной бинаризации Вульфа.
  10) Алгоритм адаптивной бинаризации Феня и Тана.
  11) Алгоритм адаптивной бинаризации NICK.

### Эндпоинты:
@app.post("/binary_image")<br>
Дает возможность загрузить изображение в формате строки base64. Должно вернуть бинаризованное изображение в том же формате.

## Брутфорс (Этап 1)
Полный перебор (или метод «грубой силы», англ. brute force) — метод решения математических задач. Относится к классу методов поиска решения исчерпыванием всевозможных вариантов[англ.]. Сложность полного перебора зависит от количества всех возможных решений задачи. Если пространство решений очень велико, то полный перебор может не дать результатов в течение нескольких лет или даже столетий.<br>
[К ознакомлению](https://habr.com/ru/companies/otus/articles/846872/)


Для начала попробуем разработать алгорим брутфорса
своими средствами.
Ломать будем пароленный rar-архив.

Алгоритм будет состоять из нескольких этапов. 
1) Извлечения хеша из RAR-архива (можно использовать сторонние библиотеки, к примеру rar2john из набора John the Ripper)
2) Определяемся со словарем из символов, которые потенциально могут быть в пароле, а также с его максимальной длиной.
3) Сгенерировать все возможные пароли и занести их в файл.
4) Осуществить эффективную брутфорс атаку на хеш архива.

### Эндпоинты:
@app.post("/brut_hash")<br>
Принимает хеш, словарь, максимальное количество символов (с ограничением в 8) и возвращает id задачи.<br>
@app.get("/get_status")
Принимает id и возвращает статус задачи.

## Курсы по fast api
[Артем Шумейко](https://youtube.com/playlist?list=PLuW7Z72R04bi313KhHamabibc8JW2HDU3&si=pw4q-OImqdknAo7c)  <br>
[Программирование и иже с ним(смотреть на свой страх и риск, но чувак сильный)](https://youtube.com/playlist?list=PLeLN0qH0-mCVQKZ8-W1LhxDcVlWtTALCS&si=swC88v6orGsczS0S)

## Распределение
[gsheets](https://docs.google.com/spreadsheets/d/1uzmd1FTQv-3XlK1xgTwTjuGs_30tBCZ0Kqic1MXAyc4/edit?gid=0#gid=0)