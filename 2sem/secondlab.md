
# Лабораторная работа №3: Разработка асинхронного API с WebSocket и Celery

В данной лабораторной работе вам предстоит расширить функциональность ваших проектов, созданных в первой лабораторной работе. Вы будете интегрировать технологию WebSocket для обеспечения двусторонней связи в режиме реального времени, а также использовать Celery для выполнения длительных задач в фоновом режиме с отправкой уведомлений через WebSocket.

# Общие требования
Доработать серверную часть для поддержки WebSocket-соединений
Интегрировать Celery для обработки длительных задач
Настроить отправку уведомлений через WebSocket при завершении задач Celery
Разработать консольный клиент для взаимодействия с сервером

# Лабораторная работа №2: Разработка асинхронного API с WebSocket и Celery

В данной лабораторной работе вам предстоит расширить функциональность ваших проектов, созданных в первой лабораторной работе. Вы будете интегрировать технологию WebSocket для обеспечения двусторонней связи в режиме реального времени, а также использовать Celery для выполнения длительных задач в фоновом режиме с отправкой уведомлений через WebSocket.

## Общие требования
- Доработать серверную часть для поддержки WebSocket-соединений
- Интегрировать Celery для обработки длительных задач
- Настроить отправку уведомлений через WebSocket при завершении задач Celery
- Разработать консольный клиент для взаимодействия с сервером
- Сохранить функциональность REST API из предыдущей лабораторной работы

## Использованать redislite вместо Redis!

## Структура проекта

project/   
├── app/ 
│   ├── api/           # эндпоинты 
│   ├── core/          # config 
│   ├── db/            # файл базы данных и сессия подключения 
│   ├── models/        # модели для базы данных 
│   ├── cruds/         # ORM CRUD операции 
│   ├── schemas/       # схемы запросов 
│   ├── services/      # доп. сервисы и логика 
│   ├── celery/        # настройки и задачи Celery 
│   └── websocket/     # модули для работы с WebSocket 
├── main.py 
├── alembic/ 
└── .env




## Требования к WebSocket

1.  Создать эндпоинты для подключения через WebSocket
2.  Организовать уведомления о ходе выполнения длительных задач
3.  Реализовать отправку окончательных результатов по завершении задач
## Требования к Celery

1.  Настроить Celery с использованием redislite в качестве брокера и бэкенда
2.  Создать задачи для выполнения длительных операций
3.  Организовать обновление статуса выполнения задач
4.  Настроить отправку уведомлений через WebSocket
    

## Требования к консольному клиенту

1.  Реализовать интерактивный режим с приглашением к вводу команд
2.  Добавить поддержку выполнения скрипта из файла
3.  Реализовать подключение к WebSocket и обработку сообщений
4.  Разработать механизм аутентификации и передачи токена

# Варианты

## Вариант 1. Задача коммивояжёра - WebSocket оповещения


Для каждого пользователя должен быть создан отдельный канал WebSocket, который будет отправлять клиенту следующие уведомления:

1.  Оповещение о начале выполнения задачи:
    

json
```
{ 
  "status": "STARTED",
  "task_id": "unique-task-id",
  "message": "Задача запущена"
}
```

2.  Оповещение о прогрессе выполнения:
    

json

```
{
  "status": "PROGRESS",
  "task_id": "unique-task-id",
  "progress": 45
}
``` 

3.  Оповещение о завершении задачи:
    

json

```
{
  "status": "COMPLETED",
  "task_id": "unique-task-id",
  "path": [1, 2, 3, 4, 1],
  "total_distance": 10
}
``` 

Важно: если клиент отправил несколько задач, сервер должен присвоить каждой задаче уникальный идентификатор и отправлять уведомления по каждой из них. Клиент должен уметь обрабатывать параллельные уведомления от разных задач, отличая их по  ```task_id```.

## Вариант 2. Шифрование данных - WebSocket оповещения

Для каждого пользователя должен быть создан отдельный канал WebSocket, который будет отправлять клиенту следующие уведомления:

1.  Оповещение о начале выполнения:
    

json

```
{
  "status": "STARTED",
  "task_id": "unique-task-id",
  "operation": "encode/decode"
}
``` 

2.  Оповещение о прогрессе:
    

json

```
{
  "status": "PROGRESS",
  "task_id": "unique-task-id",
  "operation": "encode/decode",
  "progress": 50
}
``` 

3.  Оповещение о завершении:
    

json

```
{
  "status": "COMPLETED",
  "task_id": "unique-task-id",
  "operation": "encode/decode",
  "result": {
    "encoded_data": "base64_encoded_string",
    "huffman_codes": {
      "...": "..."
    },
    "padding": 4
  }
}
``` 

При отправке клиентом нескольких задач, каждая задача должна обрабатываться независимо и иметь собственный канал уведомлений с уникальным  ```task_id```. Клиент должен поддерживать одновременное прослушивание нескольких WebSocket-соединений.

## Вариант 3. Нечеткий поиск - WebSocket оповещения

Для каждого пользователя должен быть создан отдельный канал WebSocket, который будет отправлять клиенту следующие уведомления:

1.  Начало обработки:
    

json

```
{
  "status": "STARTED",
  "task_id": "unique-task-id",
  "word": "поисковое_слово",
  "algorithm": "имя_алгоритма"
}
``` 

2.  Прогресс обработки:
    

json

```
{
  "status": "PROGRESS",
  "task_id": "unique-task-id",
  "progress": 75,
  "current_word": "processing word 75/100"
}
``` 

3.  Завершение задачи:
    

json

```
{
  "status": "COMPLETED",
  "task_id": "unique-task-id",
  "execution_time": 1.25,
  "results": [
    {
      "word": "example",
      "distance": 0
    },
    {
      "word": "sample",
      "distance": 2
    }
  ]
}
``` 

Если клиент запустил несколько поисковых задач с разными алгоритмами или словами, система должна отправлять уведомления по каждой задаче отдельно, включая уникальный идентификатор. Клиент должен корректно обрабатывать множественные уведомления, сопоставляя их с соответствующими запросами.

## Вариант 4. Бинаризация изображений - WebSocket оповещения


Для каждого пользователя должен быть создан отдельный канал WebSocket, который будет отправлять клиенту следующие уведомления:

1.  Начало обработки:
    

json

```
{
  "status": "STARTED",
  "task_id": "unique-task-id",
  "algorithm": "название_алгоритма"
}
``` 

2.  Прогресс бинаризации:
    

json

```
{
  "status": "PROGRESS",
  "task_id": "unique-task-id",
  "progress": 60
}
``` 

3.  Завершение обработки:
    

json

```
{
  "status": "COMPLETED",
  "task_id": "unique-task-id",
  "binarized_image": "base64_encoded_binarized_image_string"
}
``` 

При обработке нескольких изображений одновременно каждое изображение должно обрабатываться в отдельной задаче с уникальным идентификатором. Клиент должен иметь возможность отслеживать прогресс каждой задачи независимо и получать соответствующие результаты по мере их завершения.

## Вариант 5. Брутфорс - WebSocket оповещения


Для каждого пользователя должен быть создан отдельный канал WebSocket, который будет отправлять клиенту следующие уведомления:

1.  Начало процесса:
    

json

```
{
  "status": "STARTED",
  "task_id": "unique-task-id",
  "hash_type": "rar",
  "charset_length": 62,
  "max_length": 8
}
``` 

2.  Прогресс перебора:
    

json

```
{
  "status": "PROGRESS",
  "task_id": "unique-task-id",
  "progress": 30,
  "current_combination": "abc",
  "combinations_per_second": 15000
}
``` 

3.  Завершение процесса:
    

json

```
{
  "status": "COMPLETED",
  "task_id": "unique-task-id",
  "result": "найденный_пароль",
  "elapsed_time": "00:05:23"
}
``` 


При запуске нескольких брутфорс-задач сервер должен обрабатывать каждую задачу параллельно и отправлять уведомления с соответствующим  ```task_id```. Клиент должен уметь управлять несколькими задачами одновременно (приостанавливать, возобновлять или отменять выполнение).

## Вариант 6. Парсинг сайта и построение графа - WebSocket оповещения


Для каждого пользователя должен быть создан отдельный канал WebSocket, который будет отправлять клиенту следующие уведомления:

1.  Начало парсинга:
    

json

```
{
  "status": "STARTED",
  "task_id": "unique-task-id",
  "url": "https://example.com",
  "max_depth": 3
}
``` 

2.  Прогресс парсинга:
    

json

```
{
  "status": "PROGRESS",
  "task_id": "unique-task-id",
  "progress": 75,
  "current_url": "https://example.com/page3",
  "pages_parsed": 45,
  "total_pages": 60,
  "links_found": 120
}
``` 

3.  Завершение парсинга:


```
{
  "status": "COMPLETED",
  "task_id": "unique-task-id",
  "total_pages": 60,
  "total_links": 150,
  "elapsed_time": "00:02:45",
  "result": "содержимое GraphML файла или ссылка на него"
}
``` 

При запуске парсинга нескольких сайтов каждая задача должна выполняться независимо и иметь свой уникальный идентификатор. Сервер должен корректно идентифицировать, к какой задаче относится каждое уведомление, и отправлять их через соответствующие WebSocket-соединения. Клиент должен уметь обрабатывать несколько потоков уведомлений одновременно.
Сохранить функциональность REST API из предыдущей лабораторной работы
